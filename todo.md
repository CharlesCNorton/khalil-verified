# Khalil-Verified: Outstanding Issues

1. Make `is_well_formed_rhyme` check adjacency constraints (ridf must immediately precede rawīy), not just relative ordering.
2. Replace the abstract `rhyme_id = nat` with a type derived from actual rawīy consonant and vowel identity, connecting rhyme elements to rhyme identity. **Currently rhyme is entirely abstract — `nat` equality says nothing about phonological content. The rhyme section proves structural properties of a type that doesn't model what rhyme actually is.**
3. Make `is_matla_proper` verify phonological rhyme content rather than abstract nat equality.
4. Enforce poem non-emptiness at the type level or make `is_valid_poem` reject empty lists. (`qasida` record enforces non-emptiness; `is_valid_poem` on plain `poem` type still accepts `[]`.)
5. Formalize poem sub-genres (ghazal, rubāʿī, maqṭūʿa) as structural predicates over the `poem` type.
6. Generalize mutaḥarrik-modifying lemmas (`iḍmār_preserves_morae`, `shamm_preserves_morae`, `ʿaṣb_preserves_morae`, `waqṣ_reduces_morae`, `ʿaql_reduces_morae`, and corresponding count lemmas) to pattern-general lemmas analogous to `delete_sakin_preserves_count`, eliminating the per-foot `destruct f` proofs.
7. Prove correctness of compound zihāf simultaneous deletion. `apply_khabl` uses `delete_at 1 (delete_at 3 ls)` (simultaneous) while `apply_khazl` uses sequential composition (iḍmār then tayy). There is no theorem proving that the simultaneous approach for khabl/shakl is equivalent to sequential application of their component operations (or, if it isn't equivalent, documenting why the simultaneous version is the correct one). This is a proof obligation about the internal consistency of the variation model.
8. Introduce a `SuperLong` weight constructor to distinguish tarfīl from tadhyīl at the type level. Currently `tarfīl_eq_tadhyīl` proves them extensionally identical, meaning the formalization conflates two traditionally distinct operations. This propagates changes throughout the weight type and all downstream definitions.
9. Add Ltac automation for exhaustive case splits on `foot`, `meter`, `zihaf`, `ʿilla`, and `compound_zihaf` types. The current 8-way foot destructs and 16-way meter destructs are done manually every time; a `decide_by_exhaustion` tactic or similar would eliminate hundreds of repetitive proof lines.
10. Strengthen witnesses and counterexamples so that each one tests a property the universal lemma does NOT already guarantee — e.g., boundary cases, off-by-one positions, interaction between operations, or coverage of all constructors. Beyond strengthening, aggressively cull the trivial ones: the file currently has ~2000+ lines of `Example` blocks proved by `reflexivity` that add no proof-theoretic value (e.g., `weight_eq_dec Short Short = left eq_refl`, `NoDup [Faulun; Faulun]` failing). Item 9 addresses quality; this addresses quantity — at least half should be deleted outright.
11. Add meter-specific ḥashw refinements to `foot_permitted_zihaf` — e.g., kaff on mafāʿīlun is rare/ugly in Ṭawīl but acceptable in other meters. Currently the rules are per-foot-type only, with no meter-level overrides.
12. Generalize `rotate_add_mod` to arbitrary naturals. The current preconditions (`n ≤ length p`, `m ≤ length p`) don't cover arbitrary rotation amounts, and the proof manually handles `n + m = 2 * length p` as a special case without handling larger sums. A proper version should state the theorem for all `n, m : nat` by reducing mod `length p` first, or at minimum document that the restricted version suffices for the circle-rotation application.
13. Add `Extraction` directives for the core computable functions (`scan`, `pattern_to_meter`, `apply_khabn`, etc.) to OCaml or Haskell, enabling use outside Coq.
14. Build an extracted test harness that runs the scanner against known syllable-weight transcriptions of classical Arabic verses (e.g., the opening of the Muʿallaqa of Imruʾ al-Qays in Ṭawīl). **This is the single most important validation step.**
